"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-qrcode-logo";
exports.ids = ["vendor-chunks/react-qrcode-logo"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-qrcode-logo/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/react-qrcode-logo/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QRCode = void 0;\nvar isEqual = __webpack_require__(/*! lodash.isequal */ \"(ssr)/./node_modules/lodash.isequal/index.js\");\nvar qrGenerator = __webpack_require__(/*! qrcode-generator */ \"(ssr)/./node_modules/qrcode-generator/qrcode.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar QRCode = /** @class */ (function (_super) {\n    __extends(QRCode, _super);\n    function QRCode(props) {\n        var _this = _super.call(this, props) || this;\n        _this.canvasRef = React.createRef();\n        return _this;\n    }\n    QRCode.prototype.download = function (fileType, fileName) {\n        if (this.canvasRef.current) {\n            var mimeType = void 0;\n            switch (fileType) {\n                case 'jpg':\n                    mimeType = 'image/jpeg';\n                    break;\n                case 'webp':\n                    mimeType = 'image/webp';\n                    break;\n                case 'png':\n                default:\n                    mimeType = 'image/png';\n                    break;\n            }\n            var url = this.canvasRef.current.toDataURL(mimeType, 1.0);\n            var link = document.createElement('a');\n            link.download = fileName !== null && fileName !== void 0 ? fileName : 'react-qrcode-logo';\n            link.href = url;\n            link.click();\n        }\n    };\n    QRCode.prototype.utf16to8 = function (str) {\n        var out = '', i, c;\n        var len = str.length;\n        for (i = 0; i < len; i++) {\n            c = str.charCodeAt(i);\n            if ((c >= 0x0001) && (c <= 0x007F)) {\n                out += str.charAt(i);\n            }\n            else if (c > 0x07FF) {\n                out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));\n                out += String.fromCharCode(0x80 | ((c >> 6) & 0x3F));\n                out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F));\n            }\n            else {\n                out += String.fromCharCode(0xC0 | ((c >> 6) & 0x1F));\n                out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F));\n            }\n        }\n        return out;\n    };\n    /**\n     * Draw a rounded square in the canvas\n     */\n    QRCode.prototype.drawRoundedSquare = function (lineWidth, x, y, size, color, radii, fill, ctx) {\n        ctx.lineWidth = lineWidth;\n        ctx.fillStyle = color;\n        ctx.strokeStyle = color;\n        // Adjust coordinates so that the outside of the stroke is aligned to the edges\n        y += lineWidth / 2;\n        x += lineWidth / 2;\n        size -= lineWidth;\n        if (!Array.isArray(radii)) {\n            radii = [radii, radii, radii, radii];\n        }\n        // Radius should not be greater than half the size or less than zero\n        radii = radii.map(function (r) {\n            r = Math.min(r, size / 2);\n            return (r < 0) ? 0 : r;\n        });\n        var rTopLeft = radii[0] || 0;\n        var rTopRight = radii[1] || 0;\n        var rBottomRight = radii[2] || 0;\n        var rBottomLeft = radii[3] || 0;\n        ctx.beginPath();\n        ctx.moveTo(x + rTopLeft, y);\n        ctx.lineTo(x + size - rTopRight, y);\n        if (rTopRight)\n            ctx.quadraticCurveTo(x + size, y, x + size, y + rTopRight);\n        ctx.lineTo(x + size, y + size - rBottomRight);\n        if (rBottomRight)\n            ctx.quadraticCurveTo(x + size, y + size, x + size - rBottomRight, y + size);\n        ctx.lineTo(x + rBottomLeft, y + size);\n        if (rBottomLeft)\n            ctx.quadraticCurveTo(x, y + size, x, y + size - rBottomLeft);\n        ctx.lineTo(x, y + rTopLeft);\n        if (rTopLeft)\n            ctx.quadraticCurveTo(x, y, x + rTopLeft, y);\n        ctx.closePath();\n        ctx.stroke();\n        if (fill) {\n            ctx.fill();\n        }\n    };\n    /**\n     * Draw a single positional pattern eye.\n     */\n    QRCode.prototype.drawPositioningPattern = function (ctx, cellSize, offset, row, col, color, radii) {\n        if (radii === void 0) { radii = [0, 0, 0, 0]; }\n        var lineWidth = Math.ceil(cellSize);\n        var radiiOuter;\n        var radiiInner;\n        if (typeof radii !== 'number' && !Array.isArray(radii)) {\n            radiiOuter = radii.outer || 0;\n            radiiInner = radii.inner || 0;\n        }\n        else {\n            radiiOuter = radii;\n            radiiInner = radiiOuter;\n        }\n        var colorOuter;\n        var colorInner;\n        if (typeof color !== 'string') {\n            colorOuter = color.outer;\n            colorInner = color.inner;\n        }\n        else {\n            colorOuter = color;\n            colorInner = color;\n        }\n        var y = (row * cellSize) + offset;\n        var x = (col * cellSize) + offset;\n        var size = cellSize * 7;\n        // Outer box\n        this.drawRoundedSquare(lineWidth, x, y, size, colorOuter, radiiOuter, false, ctx);\n        // Inner box\n        size = cellSize * 3;\n        y += cellSize * 2;\n        x += cellSize * 2;\n        this.drawRoundedSquare(lineWidth, x, y, size, colorInner, radiiInner, true, ctx);\n    };\n    ;\n    /**\n     * Is this dot inside a positional pattern zone.\n     */\n    QRCode.prototype.isInPositioninZone = function (col, row, zones) {\n        return zones.some(function (zone) { return (row >= zone.row && row <= zone.row + 7 &&\n            col >= zone.col && col <= zone.col + 7); });\n    };\n    QRCode.prototype.transformPixelLengthIntoNumberOfCells = function (pixelLength, cellSize) {\n        return pixelLength / cellSize;\n    };\n    QRCode.prototype.isCoordinateInImage = function (col, row, dWidthLogo, dHeightLogo, dxLogo, dyLogo, cellSize, logoImage) {\n        if (logoImage) {\n            var numberOfCellsMargin = 2;\n            var firstRowOfLogo = this.transformPixelLengthIntoNumberOfCells(dxLogo, cellSize);\n            var firstColumnOfLogo = this.transformPixelLengthIntoNumberOfCells(dyLogo, cellSize);\n            var logoWidthInCells = this.transformPixelLengthIntoNumberOfCells(dWidthLogo, cellSize) - 1;\n            var logoHeightInCells = this.transformPixelLengthIntoNumberOfCells(dHeightLogo, cellSize) - 1;\n            return row >= firstRowOfLogo - numberOfCellsMargin && row <= firstRowOfLogo + logoWidthInCells + numberOfCellsMargin // check rows\n                && col >= firstColumnOfLogo - numberOfCellsMargin && col <= firstColumnOfLogo + logoHeightInCells + numberOfCellsMargin; // check cols\n        }\n        else {\n            return false;\n        }\n    };\n    QRCode.prototype.shouldComponentUpdate = function (nextProps) {\n        return !isEqual(this.props, nextProps);\n    };\n    QRCode.prototype.componentDidMount = function () {\n        this.update();\n    };\n    QRCode.prototype.componentDidUpdate = function () {\n        this.update();\n    };\n    QRCode.prototype.update = function () {\n        var _a;\n        var _b = this.props, value = _b.value, ecLevel = _b.ecLevel, enableCORS = _b.enableCORS, bgColor = _b.bgColor, fgColor = _b.fgColor, logoImage = _b.logoImage, logoOpacity = _b.logoOpacity, logoOnLoad = _b.logoOnLoad, removeQrCodeBehindLogo = _b.removeQrCodeBehindLogo, qrStyle = _b.qrStyle, eyeRadius = _b.eyeRadius, eyeColor = _b.eyeColor, logoPaddingStyle = _b.logoPaddingStyle;\n        // just make sure that these params are passed as numbers\n        var size = +this.props.size;\n        var quietZone = +this.props.quietZone;\n        var logoWidth = this.props.logoWidth ? +this.props.logoWidth : 0;\n        var logoHeight = this.props.logoHeight ? +this.props.logoHeight : 0;\n        var logoPadding = this.props.logoPadding ? +this.props.logoPadding : 0;\n        var qrCode = qrGenerator(0, ecLevel);\n        qrCode.addData(this.utf16to8(value));\n        qrCode.make();\n        var canvas = (_a = this.canvasRef) === null || _a === void 0 ? void 0 : _a.current;\n        var ctx = canvas.getContext('2d');\n        var canvasSize = size + (2 * quietZone);\n        var length = qrCode.getModuleCount();\n        var cellSize = size / length;\n        var scale = (window.devicePixelRatio || 1);\n        canvas.height = canvas.width = canvasSize * scale;\n        ctx.scale(scale, scale);\n        ctx.fillStyle = bgColor;\n        ctx.fillRect(0, 0, canvasSize, canvasSize);\n        var offset = quietZone;\n        var positioningZones = [\n            { row: 0, col: 0 },\n            { row: 0, col: length - 7 },\n            { row: length - 7, col: 0 },\n        ];\n        ctx.strokeStyle = fgColor;\n        if (qrStyle === 'dots') {\n            ctx.fillStyle = fgColor;\n            var radius = cellSize / 2;\n            for (var row = 0; row < length; row++) {\n                for (var col = 0; col < length; col++) {\n                    if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {\n                        ctx.beginPath();\n                        ctx.arc(Math.round(col * cellSize) + radius + offset, Math.round(row * cellSize) + radius + offset, (radius / 100) * 75, 0, 2 * Math.PI, false);\n                        ctx.closePath();\n                        ctx.fill();\n                    }\n                }\n            }\n        }\n        else if (qrStyle === 'fluid') {\n            var radius = Math.ceil(cellSize / 2);\n            for (var row = 0; row < length; row++) {\n                for (var col = 0; col < length; col++) {\n                    if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {\n                        var roundedCorners = [false, false, false, false]; // top-left, top-right, bottom-right, bottom-left\n                        if ((row > 0 && !qrCode.isDark(row - 1, col)) && (col > 0 && !qrCode.isDark(row, col - 1)))\n                            roundedCorners[0] = true;\n                        if ((row > 0 && !qrCode.isDark(row - 1, col)) && (col < length - 1 && !qrCode.isDark(row, col + 1)))\n                            roundedCorners[1] = true;\n                        if ((row < length - 1 && !qrCode.isDark(row + 1, col)) && (col < length - 1 && !qrCode.isDark(row, col + 1)))\n                            roundedCorners[2] = true;\n                        if ((row < length - 1 && !qrCode.isDark(row + 1, col)) && (col > 0 && !qrCode.isDark(row, col - 1)))\n                            roundedCorners[3] = true;\n                        var w = (Math.ceil((col + 1) * cellSize) - Math.floor(col * cellSize));\n                        var h = (Math.ceil((row + 1) * cellSize) - Math.floor(row * cellSize));\n                        ctx.fillStyle = fgColor;\n                        ctx.beginPath();\n                        ctx.arc(Math.round(col * cellSize) + radius + offset, Math.round(row * cellSize) + radius + offset, radius, 0, 2 * Math.PI, false);\n                        ctx.closePath();\n                        ctx.fill();\n                        if (!roundedCorners[0])\n                            ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset, w / 2, h / 2);\n                        if (!roundedCorners[1])\n                            ctx.fillRect(Math.round(col * cellSize) + offset + Math.floor(w / 2), Math.round(row * cellSize) + offset, w / 2, h / 2);\n                        if (!roundedCorners[2])\n                            ctx.fillRect(Math.round(col * cellSize) + offset + Math.floor(w / 2), Math.round(row * cellSize) + offset + Math.floor(h / 2), w / 2, h / 2);\n                        if (!roundedCorners[3])\n                            ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset + Math.floor(h / 2), w / 2, h / 2);\n                    }\n                }\n            }\n        }\n        else {\n            for (var row = 0; row < length; row++) {\n                for (var col = 0; col < length; col++) {\n                    if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {\n                        ctx.fillStyle = fgColor;\n                        var w = (Math.ceil((col + 1) * cellSize) - Math.floor(col * cellSize));\n                        var h = (Math.ceil((row + 1) * cellSize) - Math.floor(row * cellSize));\n                        ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset, w, h);\n                    }\n                }\n            }\n        }\n        // Draw positioning patterns\n        for (var i = 0; i < 3; i++) {\n            var _c = positioningZones[i], row = _c.row, col = _c.col;\n            var radii = eyeRadius;\n            var color = void 0;\n            if (Array.isArray(radii)) {\n                radii = radii[i];\n            }\n            if (typeof radii == 'number') {\n                radii = [radii, radii, radii, radii];\n            }\n            if (!eyeColor) { // if not specified, eye color is the same as foreground, \n                color = fgColor;\n            }\n            else {\n                if (Array.isArray(eyeColor)) { // if array, we pass the single color\n                    color = eyeColor[i];\n                }\n                else {\n                    color = eyeColor;\n                }\n            }\n            this.drawPositioningPattern(ctx, cellSize, offset, row, col, color, radii);\n        }\n        if (logoImage) {\n            var image_1 = new Image();\n            if (enableCORS) {\n                image_1.crossOrigin = 'Anonymous';\n            }\n            image_1.onload = function (e) {\n                ctx.save();\n                var dWidthLogo = logoWidth || size * 0.2;\n                var dHeightLogo = logoHeight || dWidthLogo;\n                var dxLogo = ((size - dWidthLogo) / 2);\n                var dyLogo = ((size - dHeightLogo) / 2);\n                if (removeQrCodeBehindLogo || logoPadding) {\n                    ctx.beginPath();\n                    ctx.strokeStyle = bgColor;\n                    ctx.fillStyle = bgColor;\n                    var dWidthLogoPadding = dWidthLogo + (2 * logoPadding);\n                    var dHeightLogoPadding = dHeightLogo + (2 * logoPadding);\n                    var dxLogoPadding = dxLogo + offset - logoPadding;\n                    var dyLogoPadding = dyLogo + offset - logoPadding;\n                    if (logoPaddingStyle === 'circle') {\n                        var dxCenterLogoPadding = dxLogoPadding + (dWidthLogoPadding / 2);\n                        var dyCenterLogoPadding = dyLogoPadding + (dHeightLogoPadding / 2);\n                        ctx.ellipse(dxCenterLogoPadding, dyCenterLogoPadding, dWidthLogoPadding / 2, dHeightLogoPadding / 2, 0, 0, 2 * Math.PI);\n                        ctx.stroke();\n                        ctx.fill();\n                    }\n                    else {\n                        ctx.fillRect(dxLogoPadding, dyLogoPadding, dWidthLogoPadding, dHeightLogoPadding);\n                    }\n                }\n                ctx.globalAlpha = logoOpacity;\n                ctx.drawImage(image_1, dxLogo + offset, dyLogo + offset, dWidthLogo, dHeightLogo);\n                ctx.restore();\n                if (logoOnLoad) {\n                    logoOnLoad(e);\n                }\n            };\n            image_1.src = logoImage;\n        }\n    };\n    QRCode.prototype.render = function () {\n        var _a;\n        var qrSize = +this.props.size + (2 * +this.props.quietZone);\n        return React.createElement(\"canvas\", { id: (_a = this.props.id) !== null && _a !== void 0 ? _a : 'react-qrcode-logo', height: qrSize, width: qrSize, style: __assign({ height: qrSize + 'px', width: qrSize + 'px' }, this.props.style), ref: this.canvasRef });\n    };\n    QRCode.defaultProps = {\n        value: 'https://reactjs.org/',\n        ecLevel: 'M',\n        enableCORS: false,\n        size: 150,\n        quietZone: 10,\n        bgColor: '#FFFFFF',\n        fgColor: '#000000',\n        logoOpacity: 1,\n        qrStyle: 'squares',\n        eyeRadius: [0, 0, 0],\n        logoPaddingStyle: 'square'\n    };\n    return QRCode;\n}(React.Component));\nexports.QRCode = QRCode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcXJjb2RlLWxvZ28vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxjQUFjLG1CQUFPLENBQUMsb0VBQWdCO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFrQjtBQUM1QyxZQUFZLG1CQUFPLENBQUMsd0dBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SUFBeUk7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMseUJBQXlCO0FBQ3ZDLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QyxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUMsa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QyxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdJQUFnSSw2Q0FBNkMsMENBQTBDO0FBQ3RRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FzdGUvLi9ub2RlX21vZHVsZXMvcmVhY3QtcXJjb2RlLWxvZ28vZGlzdC9pbmRleC5qcz8yNzM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlFSQ29kZSA9IHZvaWQgMDtcbnZhciBpc0VxdWFsID0gcmVxdWlyZShcImxvZGFzaC5pc2VxdWFsXCIpO1xudmFyIHFyR2VuZXJhdG9yID0gcmVxdWlyZShcInFyY29kZS1nZW5lcmF0b3JcIik7XG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgUVJDb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhRUkNvZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUVJDb2RlKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jYW52YXNSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBRUkNvZGUucHJvdG90eXBlLmRvd25sb2FkID0gZnVuY3Rpb24gKGZpbGVUeXBlLCBmaWxlTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5jYW52YXNSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIG1pbWVUeXBlID0gdm9pZCAwO1xuICAgICAgICAgICAgc3dpdGNoIChmaWxlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2pwZyc6XG4gICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlID0gJ2ltYWdlL2pwZWcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWJwJzpcbiAgICAgICAgICAgICAgICAgICAgbWltZVR5cGUgPSAnaW1hZ2Uvd2VicCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BuZyc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbWltZVR5cGUgPSAnaW1hZ2UvcG5nJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy5jYW52YXNSZWYuY3VycmVudC50b0RhdGFVUkwobWltZVR5cGUsIDEuMCk7XG4gICAgICAgICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgIGxpbmsuZG93bmxvYWQgPSBmaWxlTmFtZSAhPT0gbnVsbCAmJiBmaWxlTmFtZSAhPT0gdm9pZCAwID8gZmlsZU5hbWUgOiAncmVhY3QtcXJjb2RlLWxvZ28nO1xuICAgICAgICAgICAgbGluay5ocmVmID0gdXJsO1xuICAgICAgICAgICAgbGluay5jbGljaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRUkNvZGUucHJvdG90eXBlLnV0ZjE2dG84ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB2YXIgb3V0ID0gJycsIGksIGM7XG4gICAgICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICgoYyA+PSAweDAwMDEpICYmIChjIDw9IDB4MDA3RikpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPiAweDA3RkYpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEUwIHwgKChjID4+IDEyKSAmIDB4MEYpKTtcbiAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgKChjID4+IDYpICYgMHgzRikpO1xuICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGMgPj4gMCkgJiAweDNGKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEMwIHwgKChjID4+IDYpICYgMHgxRikpO1xuICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGMgPj4gMCkgJiAweDNGKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERyYXcgYSByb3VuZGVkIHNxdWFyZSBpbiB0aGUgY2FudmFzXG4gICAgICovXG4gICAgUVJDb2RlLnByb3RvdHlwZS5kcmF3Um91bmRlZFNxdWFyZSA9IGZ1bmN0aW9uIChsaW5lV2lkdGgsIHgsIHksIHNpemUsIGNvbG9yLCByYWRpaSwgZmlsbCwgY3R4KSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIC8vIEFkanVzdCBjb29yZGluYXRlcyBzbyB0aGF0IHRoZSBvdXRzaWRlIG9mIHRoZSBzdHJva2UgaXMgYWxpZ25lZCB0byB0aGUgZWRnZXNcbiAgICAgICAgeSArPSBsaW5lV2lkdGggLyAyO1xuICAgICAgICB4ICs9IGxpbmVXaWR0aCAvIDI7XG4gICAgICAgIHNpemUgLT0gbGluZVdpZHRoO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmFkaWkpKSB7XG4gICAgICAgICAgICByYWRpaSA9IFtyYWRpaSwgcmFkaWksIHJhZGlpLCByYWRpaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmFkaXVzIHNob3VsZCBub3QgYmUgZ3JlYXRlciB0aGFuIGhhbGYgdGhlIHNpemUgb3IgbGVzcyB0aGFuIHplcm9cbiAgICAgICAgcmFkaWkgPSByYWRpaS5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHIgPSBNYXRoLm1pbihyLCBzaXplIC8gMik7XG4gICAgICAgICAgICByZXR1cm4gKHIgPCAwKSA/IDAgOiByO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJUb3BMZWZ0ID0gcmFkaWlbMF0gfHwgMDtcbiAgICAgICAgdmFyIHJUb3BSaWdodCA9IHJhZGlpWzFdIHx8IDA7XG4gICAgICAgIHZhciByQm90dG9tUmlnaHQgPSByYWRpaVsyXSB8fCAwO1xuICAgICAgICB2YXIgckJvdHRvbUxlZnQgPSByYWRpaVszXSB8fCAwO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oeCArIHJUb3BMZWZ0LCB5KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgc2l6ZSAtIHJUb3BSaWdodCwgeSk7XG4gICAgICAgIGlmIChyVG9wUmlnaHQpXG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgc2l6ZSwgeSwgeCArIHNpemUsIHkgKyByVG9wUmlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKHggKyBzaXplLCB5ICsgc2l6ZSAtIHJCb3R0b21SaWdodCk7XG4gICAgICAgIGlmIChyQm90dG9tUmlnaHQpXG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgc2l6ZSwgeSArIHNpemUsIHggKyBzaXplIC0gckJvdHRvbVJpZ2h0LCB5ICsgc2l6ZSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHJCb3R0b21MZWZ0LCB5ICsgc2l6ZSk7XG4gICAgICAgIGlmIChyQm90dG9tTGVmdClcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBzaXplLCB4LCB5ICsgc2l6ZSAtIHJCb3R0b21MZWZ0KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgclRvcExlZnQpO1xuICAgICAgICBpZiAoclRvcExlZnQpXG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgclRvcExlZnQsIHkpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERyYXcgYSBzaW5nbGUgcG9zaXRpb25hbCBwYXR0ZXJuIGV5ZS5cbiAgICAgKi9cbiAgICBRUkNvZGUucHJvdG90eXBlLmRyYXdQb3NpdGlvbmluZ1BhdHRlcm4gPSBmdW5jdGlvbiAoY3R4LCBjZWxsU2l6ZSwgb2Zmc2V0LCByb3csIGNvbCwgY29sb3IsIHJhZGlpKSB7XG4gICAgICAgIGlmIChyYWRpaSA9PT0gdm9pZCAwKSB7IHJhZGlpID0gWzAsIDAsIDAsIDBdOyB9XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBNYXRoLmNlaWwoY2VsbFNpemUpO1xuICAgICAgICB2YXIgcmFkaWlPdXRlcjtcbiAgICAgICAgdmFyIHJhZGlpSW5uZXI7XG4gICAgICAgIGlmICh0eXBlb2YgcmFkaWkgIT09ICdudW1iZXInICYmICFBcnJheS5pc0FycmF5KHJhZGlpKSkge1xuICAgICAgICAgICAgcmFkaWlPdXRlciA9IHJhZGlpLm91dGVyIHx8IDA7XG4gICAgICAgICAgICByYWRpaUlubmVyID0gcmFkaWkuaW5uZXIgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhZGlpT3V0ZXIgPSByYWRpaTtcbiAgICAgICAgICAgIHJhZGlpSW5uZXIgPSByYWRpaU91dGVyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xvck91dGVyO1xuICAgICAgICB2YXIgY29sb3JJbm5lcjtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbG9yT3V0ZXIgPSBjb2xvci5vdXRlcjtcbiAgICAgICAgICAgIGNvbG9ySW5uZXIgPSBjb2xvci5pbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbG9yT3V0ZXIgPSBjb2xvcjtcbiAgICAgICAgICAgIGNvbG9ySW5uZXIgPSBjb2xvcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeSA9IChyb3cgKiBjZWxsU2l6ZSkgKyBvZmZzZXQ7XG4gICAgICAgIHZhciB4ID0gKGNvbCAqIGNlbGxTaXplKSArIG9mZnNldDtcbiAgICAgICAgdmFyIHNpemUgPSBjZWxsU2l6ZSAqIDc7XG4gICAgICAgIC8vIE91dGVyIGJveFxuICAgICAgICB0aGlzLmRyYXdSb3VuZGVkU3F1YXJlKGxpbmVXaWR0aCwgeCwgeSwgc2l6ZSwgY29sb3JPdXRlciwgcmFkaWlPdXRlciwgZmFsc2UsIGN0eCk7XG4gICAgICAgIC8vIElubmVyIGJveFxuICAgICAgICBzaXplID0gY2VsbFNpemUgKiAzO1xuICAgICAgICB5ICs9IGNlbGxTaXplICogMjtcbiAgICAgICAgeCArPSBjZWxsU2l6ZSAqIDI7XG4gICAgICAgIHRoaXMuZHJhd1JvdW5kZWRTcXVhcmUobGluZVdpZHRoLCB4LCB5LCBzaXplLCBjb2xvcklubmVyLCByYWRpaUlubmVyLCB0cnVlLCBjdHgpO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIElzIHRoaXMgZG90IGluc2lkZSBhIHBvc2l0aW9uYWwgcGF0dGVybiB6b25lLlxuICAgICAqL1xuICAgIFFSQ29kZS5wcm90b3R5cGUuaXNJblBvc2l0aW9uaW5ab25lID0gZnVuY3Rpb24gKGNvbCwgcm93LCB6b25lcykge1xuICAgICAgICByZXR1cm4gem9uZXMuc29tZShmdW5jdGlvbiAoem9uZSkgeyByZXR1cm4gKHJvdyA+PSB6b25lLnJvdyAmJiByb3cgPD0gem9uZS5yb3cgKyA3ICYmXG4gICAgICAgICAgICBjb2wgPj0gem9uZS5jb2wgJiYgY29sIDw9IHpvbmUuY29sICsgNyk7IH0pO1xuICAgIH07XG4gICAgUVJDb2RlLnByb3RvdHlwZS50cmFuc2Zvcm1QaXhlbExlbmd0aEludG9OdW1iZXJPZkNlbGxzID0gZnVuY3Rpb24gKHBpeGVsTGVuZ3RoLCBjZWxsU2l6ZSkge1xuICAgICAgICByZXR1cm4gcGl4ZWxMZW5ndGggLyBjZWxsU2l6ZTtcbiAgICB9O1xuICAgIFFSQ29kZS5wcm90b3R5cGUuaXNDb29yZGluYXRlSW5JbWFnZSA9IGZ1bmN0aW9uIChjb2wsIHJvdywgZFdpZHRoTG9nbywgZEhlaWdodExvZ28sIGR4TG9nbywgZHlMb2dvLCBjZWxsU2l6ZSwgbG9nb0ltYWdlKSB7XG4gICAgICAgIGlmIChsb2dvSW1hZ2UpIHtcbiAgICAgICAgICAgIHZhciBudW1iZXJPZkNlbGxzTWFyZ2luID0gMjtcbiAgICAgICAgICAgIHZhciBmaXJzdFJvd09mTG9nbyA9IHRoaXMudHJhbnNmb3JtUGl4ZWxMZW5ndGhJbnRvTnVtYmVyT2ZDZWxscyhkeExvZ28sIGNlbGxTaXplKTtcbiAgICAgICAgICAgIHZhciBmaXJzdENvbHVtbk9mTG9nbyA9IHRoaXMudHJhbnNmb3JtUGl4ZWxMZW5ndGhJbnRvTnVtYmVyT2ZDZWxscyhkeUxvZ28sIGNlbGxTaXplKTtcbiAgICAgICAgICAgIHZhciBsb2dvV2lkdGhJbkNlbGxzID0gdGhpcy50cmFuc2Zvcm1QaXhlbExlbmd0aEludG9OdW1iZXJPZkNlbGxzKGRXaWR0aExvZ28sIGNlbGxTaXplKSAtIDE7XG4gICAgICAgICAgICB2YXIgbG9nb0hlaWdodEluQ2VsbHMgPSB0aGlzLnRyYW5zZm9ybVBpeGVsTGVuZ3RoSW50b051bWJlck9mQ2VsbHMoZEhlaWdodExvZ28sIGNlbGxTaXplKSAtIDE7XG4gICAgICAgICAgICByZXR1cm4gcm93ID49IGZpcnN0Um93T2ZMb2dvIC0gbnVtYmVyT2ZDZWxsc01hcmdpbiAmJiByb3cgPD0gZmlyc3RSb3dPZkxvZ28gKyBsb2dvV2lkdGhJbkNlbGxzICsgbnVtYmVyT2ZDZWxsc01hcmdpbiAvLyBjaGVjayByb3dzXG4gICAgICAgICAgICAgICAgJiYgY29sID49IGZpcnN0Q29sdW1uT2ZMb2dvIC0gbnVtYmVyT2ZDZWxsc01hcmdpbiAmJiBjb2wgPD0gZmlyc3RDb2x1bW5PZkxvZ28gKyBsb2dvSGVpZ2h0SW5DZWxscyArIG51bWJlck9mQ2VsbHNNYXJnaW47IC8vIGNoZWNrIGNvbHNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUVJDb2RlLnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgICAgIHJldHVybiAhaXNFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xuICAgIH07XG4gICAgUVJDb2RlLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIFFSQ29kZS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgUVJDb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5wcm9wcywgdmFsdWUgPSBfYi52YWx1ZSwgZWNMZXZlbCA9IF9iLmVjTGV2ZWwsIGVuYWJsZUNPUlMgPSBfYi5lbmFibGVDT1JTLCBiZ0NvbG9yID0gX2IuYmdDb2xvciwgZmdDb2xvciA9IF9iLmZnQ29sb3IsIGxvZ29JbWFnZSA9IF9iLmxvZ29JbWFnZSwgbG9nb09wYWNpdHkgPSBfYi5sb2dvT3BhY2l0eSwgbG9nb09uTG9hZCA9IF9iLmxvZ29PbkxvYWQsIHJlbW92ZVFyQ29kZUJlaGluZExvZ28gPSBfYi5yZW1vdmVRckNvZGVCZWhpbmRMb2dvLCBxclN0eWxlID0gX2IucXJTdHlsZSwgZXllUmFkaXVzID0gX2IuZXllUmFkaXVzLCBleWVDb2xvciA9IF9iLmV5ZUNvbG9yLCBsb2dvUGFkZGluZ1N0eWxlID0gX2IubG9nb1BhZGRpbmdTdHlsZTtcbiAgICAgICAgLy8ganVzdCBtYWtlIHN1cmUgdGhhdCB0aGVzZSBwYXJhbXMgYXJlIHBhc3NlZCBhcyBudW1iZXJzXG4gICAgICAgIHZhciBzaXplID0gK3RoaXMucHJvcHMuc2l6ZTtcbiAgICAgICAgdmFyIHF1aWV0Wm9uZSA9ICt0aGlzLnByb3BzLnF1aWV0Wm9uZTtcbiAgICAgICAgdmFyIGxvZ29XaWR0aCA9IHRoaXMucHJvcHMubG9nb1dpZHRoID8gK3RoaXMucHJvcHMubG9nb1dpZHRoIDogMDtcbiAgICAgICAgdmFyIGxvZ29IZWlnaHQgPSB0aGlzLnByb3BzLmxvZ29IZWlnaHQgPyArdGhpcy5wcm9wcy5sb2dvSGVpZ2h0IDogMDtcbiAgICAgICAgdmFyIGxvZ29QYWRkaW5nID0gdGhpcy5wcm9wcy5sb2dvUGFkZGluZyA/ICt0aGlzLnByb3BzLmxvZ29QYWRkaW5nIDogMDtcbiAgICAgICAgdmFyIHFyQ29kZSA9IHFyR2VuZXJhdG9yKDAsIGVjTGV2ZWwpO1xuICAgICAgICBxckNvZGUuYWRkRGF0YSh0aGlzLnV0ZjE2dG84KHZhbHVlKSk7XG4gICAgICAgIHFyQ29kZS5tYWtlKCk7XG4gICAgICAgIHZhciBjYW52YXMgPSAoX2EgPSB0aGlzLmNhbnZhc1JlZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmN1cnJlbnQ7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdmFyIGNhbnZhc1NpemUgPSBzaXplICsgKDIgKiBxdWlldFpvbmUpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcXJDb2RlLmdldE1vZHVsZUNvdW50KCk7XG4gICAgICAgIHZhciBjZWxsU2l6ZSA9IHNpemUgLyBsZW5ndGg7XG4gICAgICAgIHZhciBzY2FsZSA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCA9IGNhbnZhc1NpemUgKiBzY2FsZTtcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBiZ0NvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzU2l6ZSwgY2FudmFzU2l6ZSk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBxdWlldFpvbmU7XG4gICAgICAgIHZhciBwb3NpdGlvbmluZ1pvbmVzID0gW1xuICAgICAgICAgICAgeyByb3c6IDAsIGNvbDogMCB9LFxuICAgICAgICAgICAgeyByb3c6IDAsIGNvbDogbGVuZ3RoIC0gNyB9LFxuICAgICAgICAgICAgeyByb3c6IGxlbmd0aCAtIDcsIGNvbDogMCB9LFxuICAgICAgICBdO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBmZ0NvbG9yO1xuICAgICAgICBpZiAocXJTdHlsZSA9PT0gJ2RvdHMnKSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmdDb2xvcjtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBjZWxsU2l6ZSAvIDI7XG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBsZW5ndGg7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbGVuZ3RoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXJDb2RlLmlzRGFyayhyb3csIGNvbCkgJiYgIXRoaXMuaXNJblBvc2l0aW9uaW5ab25lKHJvdywgY29sLCBwb3NpdGlvbmluZ1pvbmVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhNYXRoLnJvdW5kKGNvbCAqIGNlbGxTaXplKSArIHJhZGl1cyArIG9mZnNldCwgTWF0aC5yb3VuZChyb3cgKiBjZWxsU2l6ZSkgKyByYWRpdXMgKyBvZmZzZXQsIChyYWRpdXMgLyAxMDApICogNzUsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHFyU3R5bGUgPT09ICdmbHVpZCcpIHtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBNYXRoLmNlaWwoY2VsbFNpemUgLyAyKTtcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IGxlbmd0aDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBsZW5ndGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxckNvZGUuaXNEYXJrKHJvdywgY29sKSAmJiAhdGhpcy5pc0luUG9zaXRpb25pblpvbmUocm93LCBjb2wsIHBvc2l0aW9uaW5nWm9uZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm91bmRlZENvcm5lcnMgPSBbZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2VdOyAvLyB0b3AtbGVmdCwgdG9wLXJpZ2h0LCBib3R0b20tcmlnaHQsIGJvdHRvbS1sZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJvdyA+IDAgJiYgIXFyQ29kZS5pc0Rhcmsocm93IC0gMSwgY29sKSkgJiYgKGNvbCA+IDAgJiYgIXFyQ29kZS5pc0Rhcmsocm93LCBjb2wgLSAxKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRlZENvcm5lcnNbMF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyb3cgPiAwICYmICFxckNvZGUuaXNEYXJrKHJvdyAtIDEsIGNvbCkpICYmIChjb2wgPCBsZW5ndGggLSAxICYmICFxckNvZGUuaXNEYXJrKHJvdywgY29sICsgMSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kZWRDb3JuZXJzWzFdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocm93IDwgbGVuZ3RoIC0gMSAmJiAhcXJDb2RlLmlzRGFyayhyb3cgKyAxLCBjb2wpKSAmJiAoY29sIDwgbGVuZ3RoIC0gMSAmJiAhcXJDb2RlLmlzRGFyayhyb3csIGNvbCArIDEpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZGVkQ29ybmVyc1syXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJvdyA8IGxlbmd0aCAtIDEgJiYgIXFyQ29kZS5pc0Rhcmsocm93ICsgMSwgY29sKSkgJiYgKGNvbCA+IDAgJiYgIXFyQ29kZS5pc0Rhcmsocm93LCBjb2wgLSAxKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRlZENvcm5lcnNbM10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSAoTWF0aC5jZWlsKChjb2wgKyAxKSAqIGNlbGxTaXplKSAtIE1hdGguZmxvb3IoY29sICogY2VsbFNpemUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gKE1hdGguY2VpbCgocm93ICsgMSkgKiBjZWxsU2l6ZSkgLSBNYXRoLmZsb29yKHJvdyAqIGNlbGxTaXplKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmdDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoTWF0aC5yb3VuZChjb2wgKiBjZWxsU2l6ZSkgKyByYWRpdXMgKyBvZmZzZXQsIE1hdGgucm91bmQocm93ICogY2VsbFNpemUpICsgcmFkaXVzICsgb2Zmc2V0LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyb3VuZGVkQ29ybmVyc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoTWF0aC5yb3VuZChjb2wgKiBjZWxsU2l6ZSkgKyBvZmZzZXQsIE1hdGgucm91bmQocm93ICogY2VsbFNpemUpICsgb2Zmc2V0LCB3IC8gMiwgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyb3VuZGVkQ29ybmVyc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoTWF0aC5yb3VuZChjb2wgKiBjZWxsU2l6ZSkgKyBvZmZzZXQgKyBNYXRoLmZsb29yKHcgLyAyKSwgTWF0aC5yb3VuZChyb3cgKiBjZWxsU2l6ZSkgKyBvZmZzZXQsIHcgLyAyLCBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJvdW5kZWRDb3JuZXJzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChNYXRoLnJvdW5kKGNvbCAqIGNlbGxTaXplKSArIG9mZnNldCArIE1hdGguZmxvb3IodyAvIDIpLCBNYXRoLnJvdW5kKHJvdyAqIGNlbGxTaXplKSArIG9mZnNldCArIE1hdGguZmxvb3IoaCAvIDIpLCB3IC8gMiwgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyb3VuZGVkQ29ybmVyc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoTWF0aC5yb3VuZChjb2wgKiBjZWxsU2l6ZSkgKyBvZmZzZXQsIE1hdGgucm91bmQocm93ICogY2VsbFNpemUpICsgb2Zmc2V0ICsgTWF0aC5mbG9vcihoIC8gMiksIHcgLyAyLCBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBsZW5ndGg7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbGVuZ3RoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXJDb2RlLmlzRGFyayhyb3csIGNvbCkgJiYgIXRoaXMuaXNJblBvc2l0aW9uaW5ab25lKHJvdywgY29sLCBwb3NpdGlvbmluZ1pvbmVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZnQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IChNYXRoLmNlaWwoKGNvbCArIDEpICogY2VsbFNpemUpIC0gTWF0aC5mbG9vcihjb2wgKiBjZWxsU2l6ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSAoTWF0aC5jZWlsKChyb3cgKyAxKSAqIGNlbGxTaXplKSAtIE1hdGguZmxvb3Iocm93ICogY2VsbFNpemUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChNYXRoLnJvdW5kKGNvbCAqIGNlbGxTaXplKSArIG9mZnNldCwgTWF0aC5yb3VuZChyb3cgKiBjZWxsU2l6ZSkgKyBvZmZzZXQsIHcsIGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERyYXcgcG9zaXRpb25pbmcgcGF0dGVybnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBfYyA9IHBvc2l0aW9uaW5nWm9uZXNbaV0sIHJvdyA9IF9jLnJvdywgY29sID0gX2MuY29sO1xuICAgICAgICAgICAgdmFyIHJhZGlpID0gZXllUmFkaXVzO1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmFkaWkpKSB7XG4gICAgICAgICAgICAgICAgcmFkaWkgPSByYWRpaVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmFkaWkgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByYWRpaSA9IFtyYWRpaSwgcmFkaWksIHJhZGlpLCByYWRpaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWV5ZUNvbG9yKSB7IC8vIGlmIG5vdCBzcGVjaWZpZWQsIGV5ZSBjb2xvciBpcyB0aGUgc2FtZSBhcyBmb3JlZ3JvdW5kLCBcbiAgICAgICAgICAgICAgICBjb2xvciA9IGZnQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleWVDb2xvcikpIHsgLy8gaWYgYXJyYXksIHdlIHBhc3MgdGhlIHNpbmdsZSBjb2xvclxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGV5ZUNvbG9yW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBleWVDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYXdQb3NpdGlvbmluZ1BhdHRlcm4oY3R4LCBjZWxsU2l6ZSwgb2Zmc2V0LCByb3csIGNvbCwgY29sb3IsIHJhZGlpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9nb0ltYWdlKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2VfMSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaWYgKGVuYWJsZUNPUlMpIHtcbiAgICAgICAgICAgICAgICBpbWFnZV8xLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWFnZV8xLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICB2YXIgZFdpZHRoTG9nbyA9IGxvZ29XaWR0aCB8fCBzaXplICogMC4yO1xuICAgICAgICAgICAgICAgIHZhciBkSGVpZ2h0TG9nbyA9IGxvZ29IZWlnaHQgfHwgZFdpZHRoTG9nbztcbiAgICAgICAgICAgICAgICB2YXIgZHhMb2dvID0gKChzaXplIC0gZFdpZHRoTG9nbykgLyAyKTtcbiAgICAgICAgICAgICAgICB2YXIgZHlMb2dvID0gKChzaXplIC0gZEhlaWdodExvZ28pIC8gMik7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZVFyQ29kZUJlaGluZExvZ28gfHwgbG9nb1BhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBiZ0NvbG9yO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRXaWR0aExvZ29QYWRkaW5nID0gZFdpZHRoTG9nbyArICgyICogbG9nb1BhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZEhlaWdodExvZ29QYWRkaW5nID0gZEhlaWdodExvZ28gKyAoMiAqIGxvZ29QYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4TG9nb1BhZGRpbmcgPSBkeExvZ28gKyBvZmZzZXQgLSBsb2dvUGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5TG9nb1BhZGRpbmcgPSBkeUxvZ28gKyBvZmZzZXQgLSBsb2dvUGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ29QYWRkaW5nU3R5bGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHhDZW50ZXJMb2dvUGFkZGluZyA9IGR4TG9nb1BhZGRpbmcgKyAoZFdpZHRoTG9nb1BhZGRpbmcgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeUNlbnRlckxvZ29QYWRkaW5nID0gZHlMb2dvUGFkZGluZyArIChkSGVpZ2h0TG9nb1BhZGRpbmcgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5lbGxpcHNlKGR4Q2VudGVyTG9nb1BhZGRpbmcsIGR5Q2VudGVyTG9nb1BhZGRpbmcsIGRXaWR0aExvZ29QYWRkaW5nIC8gMiwgZEhlaWdodExvZ29QYWRkaW5nIC8gMiwgMCwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChkeExvZ29QYWRkaW5nLCBkeUxvZ29QYWRkaW5nLCBkV2lkdGhMb2dvUGFkZGluZywgZEhlaWdodExvZ29QYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBsb2dvT3BhY2l0eTtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlXzEsIGR4TG9nbyArIG9mZnNldCwgZHlMb2dvICsgb2Zmc2V0LCBkV2lkdGhMb2dvLCBkSGVpZ2h0TG9nbyk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICBpZiAobG9nb09uTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dvT25Mb2FkKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWFnZV8xLnNyYyA9IGxvZ29JbWFnZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUVJDb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHFyU2l6ZSA9ICt0aGlzLnByb3BzLnNpemUgKyAoMiAqICt0aGlzLnByb3BzLnF1aWV0Wm9uZSk7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIHsgaWQ6IChfYSA9IHRoaXMucHJvcHMuaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdyZWFjdC1xcmNvZGUtbG9nbycsIGhlaWdodDogcXJTaXplLCB3aWR0aDogcXJTaXplLCBzdHlsZTogX19hc3NpZ24oeyBoZWlnaHQ6IHFyU2l6ZSArICdweCcsIHdpZHRoOiBxclNpemUgKyAncHgnIH0sIHRoaXMucHJvcHMuc3R5bGUpLCByZWY6IHRoaXMuY2FudmFzUmVmIH0pO1xuICAgIH07XG4gICAgUVJDb2RlLmRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgdmFsdWU6ICdodHRwczovL3JlYWN0anMub3JnLycsXG4gICAgICAgIGVjTGV2ZWw6ICdNJyxcbiAgICAgICAgZW5hYmxlQ09SUzogZmFsc2UsXG4gICAgICAgIHNpemU6IDE1MCxcbiAgICAgICAgcXVpZXRab25lOiAxMCxcbiAgICAgICAgYmdDb2xvcjogJyNGRkZGRkYnLFxuICAgICAgICBmZ0NvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgIGxvZ29PcGFjaXR5OiAxLFxuICAgICAgICBxclN0eWxlOiAnc3F1YXJlcycsXG4gICAgICAgIGV5ZVJhZGl1czogWzAsIDAsIDBdLFxuICAgICAgICBsb2dvUGFkZGluZ1N0eWxlOiAnc3F1YXJlJ1xuICAgIH07XG4gICAgcmV0dXJuIFFSQ29kZTtcbn0oUmVhY3QuQ29tcG9uZW50KSk7XG5leHBvcnRzLlFSQ29kZSA9IFFSQ29kZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-qrcode-logo/dist/index.js\n");

/***/ })

};
;